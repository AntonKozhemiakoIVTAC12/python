import numpy as np

# Параметры для распределения Пуассона
lambda_parameter = 30  # Математическое ожидание
sample_size = 100  # Размер выборки

t = [] #пустой список `t`, в который будут добавляться значения выборки из распределения Пуассона
for _ in range(sample_size): #В цикле выполняется генерация случайных чисел из распределения Пуассона (`np.random.poisson(lambda_parameter)`) размером `sample_size`
    x = np.random.poisson(lambda_parameter)
    if x > 90:
        x = 90  # Ограничение максимального значения
    t.append(x) #Полученное значение добавляется в список `t`

mean = np.mean(t)
variance = np.var(t)
std_deviation = np.sqrt(variance)

print('Математическое ожидание (среднее):', mean)
print('Дисперсия:', variance)
print('Среднеквадратичное отклонение:', std_deviation)

t.sort() #Список `t` сортируется по возрастанию
print('Минимальное:', t[0], 'Максимальное:', t[-1], '\n')
print('Сгенерированный массив случайных чисел: ', t, '\n')

e1 = []
e2 = []
e3 = []
j = 0
fx = 0

for i in t: #В цикле происходит обработка каждого элемента `i` из списка `t`. Если `j` равен `i`, то цикл продолжается дальше без выполнения последующих операций
    if j == i:
        continue
    fx += t.count(i) #Если `j` не равен `i`, то значение `t.count(i)` (количество повторений значения `i` в списке `t`) прибавляется к переменной `fx`
    e1.append(i)
    e2.append(str(fx / sample_size).replace('.', ',')) #Строковое представление значения `fx / sample_size` с заменой точки на запятую добавляется в список `e2`
    e3.append(str(t.count(i) / sample_size).replace('.', ','))
    j = i

print('Уникальные значения: ', e1, '\n')
print('Средняя частота появления уникальных значений: ', e2, '\n')
print('Относительная частота появления уникальных значений: ', e3, '\n')

e4 = [[] for _ in range(10)] #Создается список `e4`, содержащий 10 пустых списков (интервалов)
for i in t: #В цикле происходит обработка каждого элемента `i` из списка `t`
    for k in range(1, 11): #Во вложенном цикле происходит проверка, в какой интервал попадает значение `i` с учетом границ возможных значений (`t[0] + 2 * k`). Если попадает, то значение `i` добавляется в соответствующий интервал списка `e4` и цикл прерывается
        if i < t[0] + 2 * k:
            e4[k - 1].append(i)
            break
print('Интервалы: ', e4, '\n')
print('Количество значений в каждом интервале: ')

g = []
for i in e4:
    g.append(len(i))
    print(len(i), end=' ')

